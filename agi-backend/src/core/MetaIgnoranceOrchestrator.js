/**
 * MetaIgnoranceOrchestrator - Orchestratore principale del sistema AGI
 * Coordina emisferi, gestisce meta-ignorance e auto-generazione
 */

const Hemisphere = require('./Hemisphere');
const HemisphereFactory = require('./HemisphereFactory');
const crypto = require('crypto');
const { EventEmitter } = require('events');

class MetaIgnoranceOrchestrator extends EventEmitter {
  constructor(database, resourceManager, config = {}) {
    super();
    
    this.database = database;
    this.resourceManager = resourceManager;
    
    this.config = {
      confidenceThreshold: config.confidenceThreshold || 0.5,
      metaIgnoranceThreshold: config.metaIgnoranceThreshold || 0.4,
      autoGenerationEnabled: config.autoGenerationEnabled !== false,
      maxConcurrentQueries: config.maxConcurrentQueries || 10,
      queryTimeout: config.queryTimeout || 30000,
      cacheEnabled: config.cacheEnabled !== false,
      ...config
    };

    // Emisferi attivi
    this.hemispheres = new Map();
    
    // Factory per auto-generazione
    this.hemisphereFactory = new HemisphereFactory(config);
    
    // Metriche di performance
    this.performanceMetrics = [];
    
    // Query attive
    this.activeQueries = new Map();
    
    // Meta-ignorance tracking
    this.knowledgeGaps = new Map();
    this.ignorancePatterns = [];
    
    // Statistiche
    this.stats = {
      totalQueries: 0,
      successfulQueries: 0,
      failedQueries: 0,
      autoGeneratedHemispheres: 0,
      averageConfidence: 0,
      averageResponseTime: 0
    };

    this.initializeSystem();
  }

  /**
   * Inizializza il sistema con emisferi base
   */
  async initializeSystem() {
    console.log('üß† Inizializzazione MetaIgnoranceOrchestrator...');
    
    try {
      // Carica emisferi esistenti dal database
      await this.loadHemispheresFromDatabase();
      
      // Se non ci sono emisferi, crea quelli base
      if (this.hemispheres.size === 0) {
        await this.createBaseHemispheres();
      }
      
      // Setup event listeners
      this.setupEventListeners();
      
      console.log(`‚úÖ Sistema inizializzato con ${this.hemispheres.size} emisferi`);
      this.emit('systemInitialized', {
        hemispheres: this.hemispheres.size,
        timestamp: new Date()
      });
      
    } catch (error) {
      console.error('‚ùå Errore durante l\'inizializzazione:', error);
      throw error;
    }
  }

  /**
   * Carica emisferi dal database
   */
  async loadHemispheresFromDatabase() {
    try {
      const hemisphereData = await this.database.getAllHemispheres();
      
      for (const data of hemisphereData) {
        const hemisphere = Hemisphere.deserialize(data);
        this.hemispheres.set(hemisphere.domain, hemisphere);
      }
      
      console.log(`üìö Caricati ${hemisphereData.length} emisferi dal database`);
    } catch (error) {
      console.log('üìö Nessun emisfero trovato nel database, creazione ex-novo');
    }
  }

  /**
   * Crea emisferi base del sistema
   */
  async createBaseHemispheres() {
    const baseDomains = ['mathematics', 'logic', 'code', 'language'];
    
    for (const domain of baseDomains) {
      const hemisphere = new Hemisphere(domain);
      this.hemispheres.set(domain, hemisphere);
      
      // Salva nel database
      await this.database.saveHemisphere(hemisphere.serialize());
    }
    
    console.log(`üèóÔ∏è Creati ${baseDomains.length} emisferi base`);
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Resource manager events
    this.resourceManager.on('healthWarning', (health) => {
      console.warn('‚ö†Ô∏è Avviso salute sistema:', health.warnings);
    });

    this.resourceManager.on('performanceMetric', (metric) => {
      this.performanceMetrics.push(metric);
    });
  }

  /**
   * Processa una query attraverso il sistema
   */
  async processQuery(query, options = {}) {
    const startTime = Date.now();
    const queryId = crypto.randomUUID();
    
    // Incrementa contatori
    this.stats.totalQueries++;
    this.resourceManager.incrementCounter('totalQueries');
    
    try {
      // Verifica cache se abilitata
      if (this.config.cacheEnabled) {
        const queryHash = this.generateQueryHash(query);
        const cachedResult = this.resourceManager.getCachedQuery(queryHash);
        
        if (cachedResult) {
          console.log(`üíæ Cache hit per query: ${query.substring(0, 50)}...`);
          return this.formatCachedResult(cachedResult, startTime);
        }
      }

      // Registra query attiva
      this.activeQueries.set(queryId, {
        query,
        startTime,
        options
      });

      // Analizza query con tutti gli emisferi
      const hemisphereAnalysis = await this.analyzeQueryWithHemispheres(query);
      
      // Determina modalit√† di processing
      const processingMode = this.determineProcessingMode(hemisphereAnalysis);
      
      let result;
      
      switch (processingMode) {
        case 'direct':
          result = await this.processDirectQuery(query, hemisphereAnalysis);
          break;
        case 'collaborative':
          result = await this.processCollaborativeQuery(query, hemisphereAnalysis);
          break;
        case 'auto_generate':
          result = await this.processWithAutoGeneration(query, hemisphereAnalysis);
          break;
        case 'meta_ignorance':
          result = await this.processMetaIgnoranceQuery(query, hemisphereAnalysis);
          break;
        default:
          result = await this.processDefaultQuery(query, hemisphereAnalysis);
      }

      // Aggiorna metriche
      const processingTime = Date.now() - startTime;
      this.updateMetrics(result, processingTime);
      
      // Esegui peer review automatica
      result = await this.performPeerReview(result, query, hemisphereAnalysis);
      
      // Cache del risultato
      if (this.config.cacheEnabled && result.success) {
        const queryHash = this.generateQueryHash(query);
        this.resourceManager.cacheQuery(queryHash, result);
      }

      // Cleanup
      this.activeQueries.delete(queryId);
      
      // Aggiungi metadata
      result.metadata = {
        ...result.metadata,
        queryId,
        processingTime,
        processingMode,
        hemisphereAnalysis: hemisphereAnalysis.map(h => ({
          domain: h.domain,
          confidence: h.confidence
        })),
        timestamp: new Date().toISOString(),
        origin: result.metadata?.origin || 'AI',
        methodology: result.metadata?.methodology || 'analisi computazionale',
        limitations: result.metadata?.limitations || ['Non validato sperimentalmente'],
        validation_status: result.metadata?.validation_status || 'peer_reviewed',
        contribution_type: result.metadata?.contribution_type || 'sintesi',
        version: result.metadata?.version || '2.0',
        reviewers: result.metadata?.reviewers || ['AI-Reviewer-1']
      };

      return result;

    } catch (error) {
      this.stats.failedQueries++;
      this.activeQueries.delete(queryId);
      
      console.error('‚ùå Errore processing query:', error);
      
      return {
        success: false,
        error: error.message,
        metadata: {
          queryId,
          processingTime: Date.now() - startTime,
          timestamp: new Date()
        }
      };
    }
  }

  /**
   * Analizza query con tutti gli emisferi
   */
  async analyzeQueryWithHemispheres(query) {
    const analysis = [];
    
    for (const [domain, hemisphere] of this.hemispheres) {
      try {
        const hemisphereAnalysis = hemisphere.analyzeQuery(query);
        analysis.push({
          domain,
          hemisphere,
          confidence: hemisphereAnalysis.confidence,
          analysis: hemisphereAnalysis
        });
      } catch (error) {
        console.warn(`‚ö†Ô∏è Errore analisi emisfero ${domain}:`, error.message);
      }
    }
    
    // Ordina per confidenza
    analysis.sort((a, b) => b.confidence - a.confidence);
    
    return analysis;
  }

  /**
   * Determina modalit√† di processing
   */
  determineProcessingMode(hemisphereAnalysis) {
    const maxConfidence = hemisphereAnalysis.length > 0 ? hemisphereAnalysis[0].confidence : 0;
    const highConfidenceCount = hemisphereAnalysis.filter(h => h.confidence > this.config.confidenceThreshold).length;
    
    if (maxConfidence >= this.config.confidenceThreshold) {
      return highConfidenceCount > 1 ? 'collaborative' : 'direct';
    } else if (maxConfidence > this.config.metaIgnoranceThreshold) {
      return this.config.autoGenerationEnabled ? 'auto_generate' : 'meta_ignorance';
    } else {
      return 'meta_ignorance';
    }
  }

  /**
   * Processing diretto con emisfero pi√π confidente
   */
  async processDirectQuery(query, hemisphereAnalysis) {
    const bestHemisphere = hemisphereAnalysis[0];
    
    console.log(`üéØ Processing diretto con emisfero: ${bestHemisphere.domain}`);
    
    const result = await bestHemisphere.hemisphere.processQuery(query);
    
    return {
      success: result.success,
      response: result.response,
      confidence: result.confidence,
      primaryHemisphere: bestHemisphere.domain,
      mode: 'direct'
    };
  }

  /**
   * Processing collaborativo con pi√π emisferi
   */
  async processCollaborativeQuery(query, hemisphereAnalysis) {
    const relevantHemispheres = hemisphereAnalysis
      .filter(h => h.confidence > this.config.confidenceThreshold)
      .slice(0, 3); // Massimo 3 emisferi
    
    console.log(`ü§ù Processing collaborativo con ${relevantHemispheres.length} emisferi`);
    
    const responses = [];
    
    for (const hemisphereData of relevantHemispheres) {
      try {
        const result = await hemisphereData.hemisphere.processQuery(query);
        if (result.success) {
          responses.push({
            domain: hemisphereData.domain,
            response: result.response,
            confidence: result.confidence
          });
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Errore emisfero ${hemisphereData.domain}:`, error.message);
      }
    }
    
    // Combina le risposte
    const combinedResponse = this.combineResponses(responses);
    const averageConfidence = responses.reduce((sum, r) => sum + r.confidence, 0) / responses.length;
    
    return {
      success: responses.length > 0,
      response: combinedResponse,
      confidence: averageConfidence,
      collaboratingHemispheres: responses.map(r => r.domain),
      mode: 'collaborative'
    };
  }

  /**
   * Processing con auto-generazione
   */
  async processWithAutoGeneration(query, hemisphereAnalysis) {
    console.log(`üîÑ Tentativo auto-generazione per query: ${query.substring(0, 50)}...`);
    
    // Analizza per nuovi domini
    const domainAnalysis = this.hemisphereFactory.analyzeQueryForDomains(query, this.hemispheres);
    
    if (domainAnalysis.shouldGenerate) {
      // Genera nuovo emisfero
      const generationResult = await this.hemisphereFactory.generateHemisphere(domainAnalysis, this.hemispheres);
      
      if (generationResult.success) {
        // Aggiungi nuovo emisfero
        this.hemispheres.set(generationResult.domain, generationResult.hemisphere);
        this.stats.autoGeneratedHemispheres++;
        this.resourceManager.incrementCounter('hemisphereCreations');
        
        // Salva nel database
        await this.database.saveHemisphere(generationResult.hemisphere.serialize());
        
        console.log(`‚ú® Nuovo emisfero generato: ${generationResult.domain}`);
        
        // Riprocessa con nuovo emisfero
        const newResult = await generationResult.hemisphere.processQuery(query);
        
        return {
          success: newResult.success,
          response: newResult.response,
          confidence: newResult.confidence,
          newHemisphere: generationResult.domain,
          mode: 'auto_generate'
        };
      }
    }
    
    // Fallback a meta-ignorance
    return this.processMetaIgnoranceQuery(query, hemisphereAnalysis);
  }

  /**
   * Processing meta-ignorance
   */
  async processMetaIgnoranceQuery(query, hemisphereAnalysis) {
    console.log(`ü§î Processing meta-ignorance per query: ${query.substring(0, 50)}...`);
    
    // Identifica gap di conoscenza
    const knowledgeGaps = this.identifyKnowledgeGaps(query, hemisphereAnalysis);
    
    // Registra ignorance pattern
    this.recordIgnorancePattern(query, hemisphereAnalysis, knowledgeGaps);
    
    // Genera risposta meta-cognitiva
    const metaResponse = this.generateMetaIgnoranceResponse(query, knowledgeGaps);
    
    return {
      success: true,
      response: metaResponse,
      confidence: 0.3, // Bassa confidenza per meta-ignorance
      knowledgeGaps,
      mode: 'meta_ignorance',
      suggestions: this.generateLearningPath(knowledgeGaps)
    };
  }

  /**
   * Processing di default
   */
  async processDefaultQuery(query, hemisphereAnalysis) {
    const bestHemisphere = hemisphereAnalysis[0];
    
    if (bestHemisphere) {
      const result = await bestHemisphere.hemisphere.processQuery(query);
      return {
        success: result.success,
        response: result.response,
        confidence: result.confidence,
        mode: 'default'
      };
    }
    
    return {
      success: false,
      error: 'Nessun emisfero disponibile per processare la query',
      mode: 'default'
    };
  }

  /**
   * Identifica gap di conoscenza
   */
  identifyKnowledgeGaps(query, hemisphereAnalysis) {
    const gaps = [];
    
    // Analizza token non riconosciuti
    const tokens = query.toLowerCase().split(/\s+/);
    const recognizedTokens = new Set();
    
    for (const analysis of hemisphereAnalysis) {
      if (analysis.analysis.tokens) {
        analysis.analysis.tokens.forEach(token => recognizedTokens.add(token));
      }
    }
    
    const unrecognizedTokens = tokens.filter(token => !recognizedTokens.has(token));
    
    if (unrecognizedTokens.length > 0) {
      gaps.push({
        type: 'vocabulary',
        tokens: unrecognizedTokens,
        severity: unrecognizedTokens.length / tokens.length
      });
    }
    
    // Analizza domini mancanti
    const maxConfidence = hemisphereAnalysis.length > 0 ? hemisphereAnalysis[0].confidence : 0;
    if (maxConfidence < this.config.metaIgnoranceThreshold) {
      gaps.push({
        type: 'domain_knowledge',
        confidence: maxConfidence,
        severity: 1 - maxConfidence
      });
    }
    
    return gaps;
  }

  /**
   * Registra pattern di ignoranza
   */
  recordIgnorancePattern(query, hemisphereAnalysis, knowledgeGaps) {
    const pattern = {
      query,
      timestamp: new Date(),
      hemisphereConfidences: hemisphereAnalysis.map(h => ({
        domain: h.domain,
        confidence: h.confidence
      })),
      knowledgeGaps,
      hash: this.generateQueryHash(query)
    };
    
    this.ignorancePatterns.push(pattern);
    
    // Mantieni solo gli ultimi 100 pattern
    if (this.ignorancePatterns.length > 100) {
      this.ignorancePatterns.shift();
    }
  }

  /**
   * Genera risposta meta-cognitiva
   */
  generateMetaIgnoranceResponse(query, knowledgeGaps) {
    const response = {
      type: 'meta_ignorance',
      content: `Non ho conoscenze sufficienti per rispondere completamente a: "${query}"`,
      analysis: {
        identifiedGaps: knowledgeGaps.length,
        gapTypes: knowledgeGaps.map(g => g.type),
        confidence: 0.3
      },
      reasoning: 'Questa risposta √® generata dal sistema di meta-ignorance che riconosce i propri limiti di conoscenza.'
    };
    
    if (knowledgeGaps.length > 0) {
      response.content += '\n\nGap di conoscenza identificati:\n';
      knowledgeGaps.forEach(gap => {
        response.content += `- ${gap.type}: ${JSON.stringify(gap)}\n`;
      });
    }
    
    return response;
  }

  /**
   * Genera percorso di apprendimento
   */
  generateLearningPath(knowledgeGaps) {
    const suggestions = [];
    
    for (const gap of knowledgeGaps) {
      switch (gap.type) {
        case 'vocabulary':
          suggestions.push(`Espandere il vocabolario con: ${gap.tokens.join(', ')}`);
          break;
        case 'domain_knowledge':
          suggestions.push('Considerare la creazione di un nuovo dominio di conoscenza');
          break;
      }
    }
    
    return suggestions;
  }

  /**
   * Combina risposte multiple
   */
  combineResponses(responses) {
    if (responses.length === 1) {
      return responses[0].response;
    }
    
    return {
      type: 'collaborative_response',
      content: 'Risposta combinata da pi√π domini di conoscenza',
      responses: responses.map(r => ({
        domain: r.domain,
        content: r.response.content || r.response,
        confidence: r.confidence
      })),
      synthesis: 'Le risposte sono state combinate considerando le diverse prospettive dei domini coinvolti.'
    };
  }

  /**
   * Genera hash per query
   */
  generateQueryHash(query) {
    return crypto.createHash('md5').update(query.toLowerCase().trim()).digest('hex');
  }

  /**
   * Formatta risultato da cache
   */
  formatCachedResult(cachedResult, startTime) {
    return {
      ...cachedResult,
      cached: true,
      metadata: {
        ...cachedResult.metadata,
        processingTime: Date.now() - startTime,
        fromCache: true
      }
    };
  }

  /**
   * Aggiorna metriche
   */
  updateMetrics(result, processingTime) {
    if (result.success) {
      this.stats.successfulQueries++;
    } else {
      this.stats.failedQueries++;
    }
    
    // Aggiorna confidenza media
    if (result.confidence !== undefined) {
      const total = this.stats.successfulQueries;
      this.stats.averageConfidence = 
        ((this.stats.averageConfidence * (total - 1)) + result.confidence) / total;
    }
    
    // Aggiorna tempo di risposta medio
    const totalQueries = this.stats.totalQueries;
    this.stats.averageResponseTime = 
      ((this.stats.averageResponseTime * (totalQueries - 1)) + processingTime) / totalQueries;
    
    // Registra metrica nel resource manager
    this.resourceManager.recordPerformanceMetric(
      'query_processing',
      processingTime,
      result.success,
      {
        confidence: result.confidence,
        mode: result.mode
      }
    );
  }

  /**
   * Calcola tempo di risposta medio
   */
  calculateAverageResponseTime() {
    return this.stats.averageResponseTime;
  }

  /**
   * Ottieni stato del sistema
   */
  getSystemStatus() {
    return {
      hemispheres: Array.from(this.hemispheres.keys()),
      totalQueries: this.stats.totalQueries,
      averageResponseTime: this.stats.averageResponseTime,
      averageConfidence: this.stats.averageConfidence,
      autoGeneratedHemispheres: this.stats.autoGeneratedHemispheres,
      activeQueries: this.activeQueries.size,
      knowledgeGaps: this.knowledgeGaps.size,
      ignorancePatterns: this.ignorancePatterns.length,
      systemHealth: this.resourceManager.getSystemStatus(),
      generationStats: this.hemisphereFactory.getGenerationStats()
    };
  }

  /**
   * Cleanup delle risorse
   */
  async cleanup() {
    console.log('üßπ Cleanup MetaIgnoranceOrchestrator...');
    
    // Salva tutti gli emisferi
    for (const [domain, hemisphere] of this.hemispheres) {
      try {
        await this.database.saveHemisphere(hemisphere.serialize());
      } catch (error) {
        console.warn(`‚ö†Ô∏è Errore salvataggio emisfero ${domain}:`, error.message);
      }
    }
    
    // Cleanup resource manager
    this.resourceManager.cleanup();
    
    // Clear data structures
    this.hemispheres.clear();
    this.activeQueries.clear();
    this.knowledgeGaps.clear();
    this.ignorancePatterns = [];
    
    this.removeAllListeners();
    
    console.log('‚úÖ Cleanup completato');
  }

  /**
   * Esegue peer review automatica del risultato
   */
  async performPeerReview(result, query, hemisphereAnalysis) {
    const review = {
      reviewer: 'AI-Reviewer-1',
      timestamp: new Date().toISOString(),
      confidence: result.confidence,
      quality_score: 0,
      issues: [],
      recommendations: [],
      requires_human_review: false
    };

    // Valutazione qualit√† basata su multiple metriche
    let qualityScore = 0;
    let totalChecks = 0;

    // 1. Controllo confidenza
    if (result.confidence >= 0.8) {
      qualityScore += 25;
    } else if (result.confidence >= 0.6) {
      qualityScore += 15;
    } else {
      review.issues.push('Confidenza bassa');
    }
    totalChecks++;

    // 2. Controllo completezza risposta
    if (result.response && typeof result.response === 'object') {
      if (result.response.content && result.response.content.length > 50) {
        qualityScore += 25;
      } else {
        review.issues.push('Risposta incompleta');
      }
    } else {
      review.issues.push('Formato risposta non valido');
    }
    totalChecks++;

    // 3. Controllo limitazioni dichiarate
    if (result.metadata && result.metadata.limitations && result.metadata.limitations.length > 0) {
      qualityScore += 25;
    } else {
      review.issues.push('Limitazioni non dichiarate');
    }
    totalChecks++;

    // 4. Controllo metodologia
    if (result.metadata && result.metadata.methodology) {
      qualityScore += 25;
    } else {
      review.issues.push('Metodologia non specificata');
    }
    totalChecks++;

    review.quality_score = Math.round(qualityScore / totalChecks);

    // Determina se richiede review umana
    if (review.quality_score < 50 || review.issues.length > 2) {
      review.requires_human_review = true;
      review.recommendations.push('Richiesta review umana per validazione');
    }

    // Aggiorna metadati del risultato
    result.metadata = {
      ...result.metadata,
      validation_status: review.requires_human_review ? 'pending_human_review' : 'peer_reviewed',
      reviewers: [...(result.metadata?.reviewers || []), review.reviewer],
      peer_review: review
    };

    // Salva review nel database
    try {
      await this.database.saveSystemEvent({
        event_type: 'peer_review',
        severity: review.requires_human_review ? 'warning' : 'info',
        message: `Peer review completata per query: ${query.substring(0, 100)}...`,
        data: JSON.stringify({
          query: query.substring(0, 200),
          review,
          hemisphere_analysis: hemisphereAnalysis
        }),
        source: 'ai_peer_review'
      });
    } catch (error) {
      console.warn('‚ö†Ô∏è Errore salvataggio peer review:', error.message);
    }

    return result;
  }
}

module.exports = MetaIgnoranceOrchestrator;

