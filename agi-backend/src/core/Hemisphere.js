/**
 * Classe base per gli emisferi del sistema AGI
 * Ogni emisfero rappresenta un dominio di conoscenza specializzato
 */

const { v4: uuidv4 } = require('uuid');
const natural = require('natural');

class Hemisphere {
  constructor(domain, config = {}) {
    this.id = uuidv4();
    this.domain = domain;
    this.createdAt = new Date();
    this.lastUsed = new Date();
    this.usageCount = 0;
    this.confidence = 0.5; // Confidenza base
    this.knowledgeBase = new Map();
    this.patterns = [];
    this.metadata = {
      version: '1.0.0',
      autoGenerated: config.autoGenerated || false,
      parentDomain: config.parentDomain || null,
      specialization: config.specialization || 'general'
    };
    
    // Configurazione specifica del dominio
    this.config = {
      maxKnowledgeItems: config.maxKnowledgeItems || 1000,
      confidenceDecay: config.confidenceDecay || 0.01,
      learningRate: config.learningRate || 0.1,
      ...config
    };

    // Inizializza il tokenizer per l'analisi del testo
    this.tokenizer = new natural.WordTokenizer();
    this.stemmer = natural.PorterStemmer;
    
    this.initializeDomain();
  }

  /**
   * Inizializza il dominio con conoscenze base
   */
  initializeDomain() {
    switch (this.domain) {
      case 'mathematics':
        this.initializeMathematics();
        break;
      case 'logic':
        this.initializeLogic();
        break;
      case 'code':
        this.initializeCode();
        break;
      case 'language':
        this.initializeLanguage();
        break;
      default:
        this.initializeGeneral();
    }
  }

  /**
   * Inizializza conoscenze matematiche
   */
  initializeMathematics() {
    this.patterns = [
      /\d+\s*[\+\-\*\/]\s*\d+/,
      /calculate|compute|solve|equation|formula/i,
      /algebra|geometry|calculus|statistics/i,
      /sum|product|derivative|integral/i
    ];
    
    this.knowledgeBase.set('basic_operations', {
      type: 'operations',
      confidence: 0.9,
      patterns: ['addition', 'subtraction', 'multiplication', 'division']
    });
    
    this.knowledgeBase.set('advanced_math', {
      type: 'concepts',
      confidence: 0.7,
      patterns: ['calculus', 'linear_algebra', 'statistics', 'probability']
    });
  }

  /**
   * Inizializza conoscenze logiche
   */
  initializeLogic() {
    this.patterns = [
      /if\s+.*\s+then/i,
      /logic|reasoning|proof|theorem/i,
      /true|false|and|or|not/i,
      /premise|conclusion|syllogism/i
    ];
    
    this.knowledgeBase.set('logical_operators', {
      type: 'operators',
      confidence: 0.9,
      patterns: ['and', 'or', 'not', 'implies', 'iff']
    });
  }

  /**
   * Inizializza conoscenze di programmazione
   */
  initializeCode() {
    this.patterns = [
      /function|class|method|variable/i,
      /javascript|python|java|c\+\+/i,
      /algorithm|data structure|recursion/i,
      /debug|compile|execute|run/i
    ];
    
    this.knowledgeBase.set('programming_concepts', {
      type: 'concepts',
      confidence: 0.8,
      patterns: ['functions', 'classes', 'variables', 'loops', 'conditions']
    });
  }

  /**
   * Inizializza conoscenze linguistiche
   */
  initializeLanguage() {
    this.patterns = [
      /grammar|syntax|semantics|pragmatics/i,
      /noun|verb|adjective|adverb/i,
      /sentence|paragraph|text|language/i,
      /translate|interpret|meaning/i
    ];
    
    this.knowledgeBase.set('linguistic_elements', {
      type: 'elements',
      confidence: 0.8,
      patterns: ['grammar', 'vocabulary', 'syntax', 'semantics']
    });
  }

  /**
   * Inizializza conoscenze generali
   */
  initializeGeneral() {
    this.patterns = [
      /what|how|why|when|where/i,
      /explain|describe|define|analyze/i
    ];
    
    this.knowledgeBase.set('general_knowledge', {
      type: 'general',
      confidence: 0.5,
      patterns: ['facts', 'concepts', 'relationships']
    });
  }

  /**
   * Analizza una query e calcola la confidenza
   */
  analyzeQuery(query) {
    const tokens = this.tokenizer.tokenize(query.toLowerCase());
    const stemmedTokens = tokens.map(token => this.stemmer.stem(token));
    
    let confidence = 0;
    let matchedPatterns = [];
    let relevantKnowledge = [];

    // Verifica pattern specifici del dominio
    for (const pattern of this.patterns) {
      if (pattern.test(query)) {
        confidence += 0.2;
        matchedPatterns.push(pattern.toString());
      }
    }

    // Verifica conoscenze nella knowledge base
    for (const [key, knowledge] of this.knowledgeBase) {
      const intersection = stemmedTokens.filter(token => 
        knowledge.patterns.some(pattern => 
          token.includes(pattern) || pattern.includes(token)
        )
      );
      
      if (intersection.length > 0) {
        confidence += knowledge.confidence * (intersection.length / tokens.length);
        relevantKnowledge.push({
          key,
          knowledge,
          matches: intersection
        });
      }
    }

    // Normalizza la confidenza
    confidence = Math.min(confidence, 1.0);
    
    // Aggiorna statistiche
    this.lastUsed = new Date();
    this.usageCount++;

    return {
      confidence,
      matchedPatterns,
      relevantKnowledge,
      tokens: stemmedTokens,
      analysis: {
        domain: this.domain,
        hemisphereId: this.id,
        processingTime: Date.now()
      }
    };
  }

  /**
   * Processa una query e genera una risposta
   */
  async processQuery(query, context = {}) {
    const analysis = this.analyzeQuery(query);
    
    if (analysis.confidence < 0.3) {
      return {
        success: false,
        confidence: analysis.confidence,
        reason: 'Confidenza insufficiente per questo dominio',
        suggestions: this.generateSuggestions(query),
        analysis
      };
    }

    try {
      const response = await this.generateResponse(query, analysis, context);
      
      // Apprendimento: aggiorna la knowledge base
      this.updateKnowledge(query, analysis, response);
      
      return {
        success: true,
        response,
        confidence: analysis.confidence,
        analysis,
        metadata: {
          domain: this.domain,
          hemisphereId: this.id,
          processingTime: Date.now() - analysis.analysis.processingTime
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        confidence: analysis.confidence,
        analysis
      };
    }
  }

  /**
   * Genera una risposta basata sull'analisi
   */
  async generateResponse(query, analysis, context) {
    // Implementazione base - può essere estesa nelle sottoclassi
    const relevantKnowledge = analysis.relevantKnowledge
      .map(rk => rk.knowledge)
      .slice(0, 3); // Limita a 3 elementi più rilevanti

    return {
      type: 'general_response',
      content: `Analisi del dominio ${this.domain}: ${query}`,
      confidence: analysis.confidence,
      sources: relevantKnowledge,
      reasoning: `Basato su ${analysis.matchedPatterns.length} pattern corrispondenti e ${analysis.relevantKnowledge.length} elementi di conoscenza rilevanti.`
    };
  }

  /**
   * Aggiorna la knowledge base con nuove informazioni
   */
  updateKnowledge(query, analysis, response) {
    const key = `learned_${Date.now()}`;
    
    this.knowledgeBase.set(key, {
      type: 'learned',
      query,
      confidence: analysis.confidence,
      response: response.type,
      timestamp: new Date(),
      patterns: analysis.tokens.slice(0, 5) // Primi 5 token più significativi
    });

    // Mantieni la knowledge base entro i limiti
    if (this.knowledgeBase.size > this.config.maxKnowledgeItems) {
      const oldestKey = Array.from(this.knowledgeBase.keys())[0];
      this.knowledgeBase.delete(oldestKey);
    }
  }

  /**
   * Genera suggerimenti per query con bassa confidenza
   */
  generateSuggestions(query) {
    const suggestions = [];
    
    // Suggerimenti basati sui pattern del dominio
    if (this.domain === 'mathematics') {
      suggestions.push('Prova a riformulare con termini matematici più specifici');
      suggestions.push('Includi numeri o operazioni matematiche');
    } else if (this.domain === 'code') {
      suggestions.push('Specifica il linguaggio di programmazione');
      suggestions.push('Includi esempi di codice o algoritmi');
    }
    
    suggestions.push(`Considera di utilizzare il dominio ${this.domain} in modo più specifico`);
    
    return suggestions;
  }

  /**
   * Ottieni statistiche dell'emisfero
   */
  getStats() {
    return {
      id: this.id,
      domain: this.domain,
      createdAt: this.createdAt,
      lastUsed: this.lastUsed,
      usageCount: this.usageCount,
      confidence: this.confidence,
      knowledgeItems: this.knowledgeBase.size,
      patterns: this.patterns.length,
      metadata: this.metadata,
      config: this.config
    };
  }

  /**
   * Serializza l'emisfero per il salvataggio
   */
  serialize() {
    return {
      id: this.id,
      domain: this.domain,
      createdAt: this.createdAt.toISOString(),
      lastUsed: this.lastUsed.toISOString(),
      usageCount: this.usageCount,
      confidence: this.confidence,
      knowledgeBase: Array.from(this.knowledgeBase.entries()),
      patterns: this.patterns.map(p => p.toString()),
      metadata: this.metadata,
      config: this.config
    };
  }

  /**
   * Deserializza un emisfero dal database
   */
  static deserialize(data) {
    const hemisphere = new Hemisphere(data.domain, data.config);
    
    hemisphere.id = data.id;
    hemisphere.createdAt = new Date(data.createdAt);
    hemisphere.lastUsed = new Date(data.lastUsed);
    hemisphere.usageCount = data.usageCount;
    hemisphere.confidence = data.confidence;
    hemisphere.knowledgeBase = new Map(data.knowledgeBase);
    hemisphere.patterns = data.patterns.map(p => new RegExp(p.slice(1, -1), p.split('/').pop()));
    hemisphere.metadata = data.metadata;
    
    return hemisphere;
  }
}

module.exports = Hemisphere;

