/**
 * Routes per informazioni e controllo sistema AGI
 */

const express = require('express');
const router = express.Router();

/**
 * GET /api/v1/system
 * Ottieni stato generale del sistema
 */
router.get('/', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;

    // Stato orchestrator
    const orchestratorStatus = orchestrator.getSystemStatus();
    
    // Stato resource manager
    const systemStatus = resourceManager.getSystemStatus();
    
    // Statistiche database
    const dbStats = await database.getDatabaseStats();

    res.json({
      status: 'operational',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      version: require('../../../package.json').version,
      environment: process.env.NODE_ENV || 'development',
      
      orchestrator: {
        hemispheres: {
          total: orchestratorStatus.hemispheres.length,
          domains: orchestratorStatus.hemispheres,
          autoGenerated: orchestratorStatus.autoGeneratedHemispheres
        },
        queries: {
          total: orchestratorStatus.totalQueries,
          active: orchestratorStatus.activeQueries,
          averageResponseTime: orchestratorStatus.averageResponseTime,
          averageConfidence: orchestratorStatus.averageConfidence
        },
        knowledgeGaps: orchestratorStatus.knowledgeGaps,
        ignorancePatterns: orchestratorStatus.ignorancePatterns
      },
      
      system: {
        health: systemStatus.health,
        memory: systemStatus.memory,
        performance: resourceManager.getPerformanceStats(),
        cache: systemStatus.cache,
        platform: systemStatus.platform,
        arch: systemStatus.arch,
        nodeVersion: systemStatus.nodeVersion
      },
      
      database: {
        size: (dbStats.databaseSize / 1024 / 1024).toFixed(2) + ' MB',
        tables: Object.fromEntries(
          Object.entries(dbStats).filter(([key]) => key !== 'databaseSize')
        )
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/system/health
 * Health check dettagliato
 */
router.get('/health', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;

    const checks = [];
    let overallStatus = 'healthy';

    // Check database
    try {
      await database.get('SELECT 1');
      checks.push({
        component: 'database',
        status: 'healthy',
        message: 'Database connection OK'
      });
    } catch (error) {
      checks.push({
        component: 'database',
        status: 'unhealthy',
        message: 'Database connection failed',
        error: error.message
      });
      overallStatus = 'unhealthy';
    }

    // Check resource manager
    const systemHealth = resourceManager.systemHealth;
    checks.push({
      component: 'resource_manager',
      status: systemHealth.status,
      message: `System health: ${systemHealth.status}`,
      warnings: systemHealth.warnings,
      errors: systemHealth.errors
    });

    if (systemHealth.status === 'critical') {
      overallStatus = 'unhealthy';
    } else if (systemHealth.status === 'warning' && overallStatus === 'healthy') {
      overallStatus = 'degraded';
    }

    // Check orchestrator
    const hemisphereCount = orchestrator.hemispheres.size;
    if (hemisphereCount >= 4) {
      checks.push({
        component: 'orchestrator',
        status: 'healthy',
        message: `${hemisphereCount} hemispheres active`
      });
    } else {
      checks.push({
        component: 'orchestrator',
        status: 'warning',
        message: `Only ${hemisphereCount} hemispheres active (expected 4+)`
      });
      if (overallStatus === 'healthy') {
        overallStatus = 'degraded';
      }
    }

    // Check memory usage
    const memoryUsage = resourceManager.getMemoryUsage();
    if (memoryUsage.system.percentage < 80) {
      checks.push({
        component: 'memory',
        status: 'healthy',
        message: `Memory usage: ${memoryUsage.system.percentage.toFixed(1)}%`
      });
    } else if (memoryUsage.system.percentage < 90) {
      checks.push({
        component: 'memory',
        status: 'warning',
        message: `High memory usage: ${memoryUsage.system.percentage.toFixed(1)}%`
      });
      if (overallStatus === 'healthy') {
        overallStatus = 'degraded';
      }
    } else {
      checks.push({
        component: 'memory',
        status: 'critical',
        message: `Critical memory usage: ${memoryUsage.system.percentage.toFixed(1)}%`
      });
      overallStatus = 'unhealthy';
    }

    const statusCode = overallStatus === 'healthy' ? 200 : 
                      overallStatus === 'degraded' ? 200 : 503;

    res.status(statusCode).json({
      status: overallStatus,
      timestamp: new Date().toISOString(),
      checks,
      uptime: process.uptime(),
      version: require('../../../package.json').version
    });

  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message,
      checks: [{
        component: 'system',
        status: 'unhealthy',
        message: 'Health check failed',
        error: error.message
      }]
    });
  }
});

/**
 * GET /api/v1/system/info
 * Informazioni dettagliate sistema
 */
router.get('/info', async (req, res, next) => {
  try {
    const orchestrator = req.app.locals.orchestrator;
    const resourceManager = req.app.locals.resourceManager;

    res.json({
      application: {
        name: 'AGI Meta-Ignorance Backend',
        version: require('../../../package.json').version,
        description: 'Backend completo per sistema AGI con Meta-Ignorance e auto-generazione emisferi',
        author: 'Manus AI',
        license: 'MIT'
      },
      
      runtime: {
        node: process.version,
        platform: process.platform,
        arch: process.arch,
        uptime: process.uptime(),
        pid: process.pid,
        memory: process.memoryUsage(),
        environment: process.env.NODE_ENV || 'development'
      },
      
      features: {
        metaIgnoranceTracking: true,
        autoGenerationHemispheres: true,
        performanceMonitoring: true,
        knowledgeGapAnalysis: true,
        collaborativeProcessing: true,
        caching: true,
        rateLimiting: true,
        realTimeMetrics: true
      },
      
      configuration: {
        maxHemispheres: process.env.MAX_HEMISPHERES || 50,
        confidenceThreshold: process.env.CONFIDENCE_THRESHOLD || 0.5,
        autoGenerationEnabled: process.env.AUTO_GENERATION_ENABLED !== 'false',
        cacheEnabled: process.env.CACHE_ENABLED !== 'false',
        rateLimitMaxRequests: process.env.RATE_LIMIT_MAX_REQUESTS || 100,
        rateLimitWindowMs: process.env.RATE_LIMIT_WINDOW_MS || 900000
      },
      
      statistics: {
        hemispheres: orchestrator.hemispheres.size,
        totalQueries: orchestrator.stats.totalQueries,
        successfulQueries: orchestrator.stats.successfulQueries,
        failedQueries: orchestrator.stats.failedQueries,
        autoGeneratedHemispheres: orchestrator.stats.autoGeneratedHemispheres,
        averageConfidence: orchestrator.stats.averageConfidence,
        averageResponseTime: orchestrator.stats.averageResponseTime
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/system/events
 * Ottieni eventi di sistema recenti
 */
router.get('/events', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    const limit = Math.min(parseInt(req.query.limit) || 50, 200);
    const severity = req.query.severity;
    const type = req.query.type;
    const hours = parseInt(req.query.hours) || 24;

    let sql = 'SELECT * FROM system_events WHERE timestamp > ?';
    const params = [new Date(Date.now() - hours * 60 * 60 * 1000).toISOString()];

    if (severity) {
      sql += ' AND severity = ?';
      params.push(severity);
    }

    if (type) {
      sql += ' AND event_type = ?';
      params.push(type);
    }

    sql += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(limit);

    const events = await database.all(sql, params);

    // Statistiche eventi
    const eventStats = await database.all(`
      SELECT 
        event_type,
        severity,
        COUNT(*) as count,
        MAX(timestamp) as last_occurrence
      FROM system_events 
      WHERE timestamp > ?
      GROUP BY event_type, severity
      ORDER BY count DESC
    `, [new Date(Date.now() - hours * 60 * 60 * 1000).toISOString()]);

    res.json({
      events: events.map(event => ({
        id: event.id,
        type: event.event_type,
        severity: event.severity,
        message: event.message,
        timestamp: event.timestamp,
        source: event.source,
        data: event.data ? JSON.parse(event.data) : {}
      })),
      statistics: eventStats,
      filters: {
        limit,
        severity,
        type,
        hours
      },
      total: events.length
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/system/gc
 * Forza garbage collection (se disponibile)
 */
router.post('/gc', async (req, res, next) => {
  try {
    const resourceManager = req.app.locals.resourceManager;

    if (global.gc) {
      const before = process.memoryUsage();
      global.gc();
      const after = process.memoryUsage();
      
      const freed = before.heapUsed - after.heapUsed;
      
      res.json({
        message: 'Garbage collection executed',
        before: {
          heapUsed: before.heapUsed,
          heapTotal: before.heapTotal,
          external: before.external,
          rss: before.rss
        },
        after: {
          heapUsed: after.heapUsed,
          heapTotal: after.heapTotal,
          external: after.external,
          rss: after.rss
        },
        freed: {
          bytes: freed,
          mb: (freed / 1024 / 1024).toFixed(2)
        },
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(400).json({
        error: 'Garbage Collection Not Available',
        message: 'Node.js was not started with --expose-gc flag'
      });
    }

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/system/config
 * Ottieni configurazione sistema (senza segreti)
 */
router.get('/config', async (req, res, next) => {
  try {
    const config = {
      server: {
        port: process.env.PORT || 3000,
        host: process.env.HOST || '0.0.0.0',
        nodeEnv: process.env.NODE_ENV || 'development'
      },
      agi: {
        maxHemispheres: parseInt(process.env.MAX_HEMISPHERES) || 50,
        autoGenerationThreshold: parseFloat(process.env.AUTO_GENERATION_THRESHOLD) || 0.3,
        confidenceThreshold: parseFloat(process.env.CONFIDENCE_THRESHOLD) || 0.5,
        metaIgnoranceThreshold: parseFloat(process.env.META_IGNORANCE_THRESHOLD) || 0.4,
        autoGenerationEnabled: process.env.AUTO_GENERATION_ENABLED !== 'false',
        metaLearningEnabled: process.env.META_LEARNING_ENABLED !== 'false'
      },
      performance: {
        maxMemoryUsage: parseFloat(process.env.MAX_MEMORY_USAGE) || 0.8,
        monitoringInterval: parseInt(process.env.MONITORING_INTERVAL) || 5000,
        performanceMetricsRetention: parseInt(process.env.PERFORMANCE_METRICS_RETENTION) || 1000,
        cacheSize: parseInt(process.env.CACHE_SIZE) || 1000
      },
      api: {
        version: process.env.API_VERSION || 'v1',
        corsOrigin: process.env.CORS_ORIGIN || '*',
        enableSwagger: process.env.ENABLE_SWAGGER === 'true',
        rateLimitMaxRequests: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
        rateLimitWindowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 900000
      },
      logging: {
        level: process.env.LOG_LEVEL || 'info',
        file: process.env.LOG_FILE || './logs/agi.log'
      }
    };

    res.json(config);

  } catch (error) {
    next(error);
  }
});

module.exports = router;

