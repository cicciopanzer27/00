/**
 * Routes amministrative per gestione sistema AGI
 */

const express = require('express');
const Joi = require('joi');
const router = express.Router();

/**
 * GET /api/v1/admin
 * Panoramica amministrativa
 */
router.get('/', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;

    // Statistiche generali
    const dbStats = await database.getDatabaseStats();
    const systemStatus = resourceManager.getSystemStatus();
    const orchestratorStatus = orchestrator.getSystemStatus();

    // Statistiche recenti (ultimi 7 giorni)
    const recentStats = await database.get(`
      SELECT 
        COUNT(*) as total_queries,
        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_queries,
        AVG(processing_time) as avg_processing_time,
        AVG(confidence) as avg_confidence
      FROM queries 
      WHERE timestamp > datetime('now', '-7 days')
    `);

    res.json({
      overview: {
        status: systemStatus.health.status,
        uptime: process.uptime(),
        version: require('../../package.json').version,
        environment: process.env.NODE_ENV || 'development'
      },
      
      database: {
        size: (dbStats.databaseSize / 1024 / 1024).toFixed(2) + ' MB',
        tables: dbStats,
        lastBackup: 'N/A' // TODO: implementare tracking backup
      },
      
      performance: {
        memory: systemStatus.memory,
        cache: systemStatus.cache,
        counters: systemStatus.counters
      },
      
      agi: {
        hemispheres: orchestratorStatus.hemispheres.length,
        autoGenerated: orchestratorStatus.autoGeneratedHemispheres,
        totalQueries: orchestratorStatus.totalQueries,
        activeQueries: orchestratorStatus.activeQueries,
        knowledgeGaps: orchestratorStatus.knowledgeGaps,
        ignorancePatterns: orchestratorStatus.ignorancePatterns
      },
      
      recent: {
        queries: recentStats || {},
        period: '7 days'
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/backup
 * Crea backup del database
 */
router.post('/backup', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    console.log('ðŸ”„ Creating database backup...');
    
    const backupPath = await database.backup();
    
    // Log evento
    await database.saveSystemEvent({
      type: 'database_backup',
      severity: 'info',
      message: 'Database backup created',
      data: { backupPath },
      source: 'admin_api'
    });

    res.json({
      message: 'Database backup created successfully',
      backupPath,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/cleanup
 * Pulizia dati vecchi
 */
router.post('/cleanup', async (req, res, next) => {
  try {
    const cleanupSchema = Joi.object({
      daysToKeep: Joi.number().integer().min(1).max(365).default(30),
      tables: Joi.array().items(
        Joi.string().valid('queries', 'performance_metrics', 'knowledge_gaps', 'system_events', 'all')
      ).default(['all'])
    });

    const { error, value } = cleanupSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.details[0].message
      });
    }

    const { daysToKeep, tables } = value;
    const database = req.app.locals.database;

    console.log(`ðŸ§¹ Starting cleanup: keeping ${daysToKeep} days of data`);

    let totalDeleted = 0;

    if (tables.includes('all') || tables.includes('queries')) {
      const result = await database.cleanup(daysToKeep);
      totalDeleted += result;
    } else {
      // Cleanup specifico per tabelle
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
      const cutoff = cutoffDate.toISOString();

      for (const table of tables) {
        if (['performance_metrics', 'knowledge_gaps', 'system_events'].includes(table)) {
          const result = await database.run(
            `DELETE FROM ${table} WHERE timestamp < ?`,
            [cutoff]
          );
          totalDeleted += result.changes || 0;
        }
      }
    }

    // Log evento
    await database.saveSystemEvent({
      type: 'data_cleanup',
      severity: 'info',
      message: `Data cleanup completed: ${totalDeleted} records removed`,
      data: { daysToKeep, tables, totalDeleted },
      source: 'admin_api'
    });

    res.json({
      message: 'Data cleanup completed',
      daysToKeep,
      tables,
      totalDeleted,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/cache/clear
 * Pulisci cache sistema
 */
router.post('/cache/clear', async (req, res, next) => {
  try {
    const resourceManager = req.app.locals.resourceManager;
    
    const cacheType = req.body.type || 'all'; // query, hemisphere, all
    
    let clearedItems = 0;

    if (cacheType === 'all' || cacheType === 'query') {
      clearedItems += resourceManager.queryCache.size;
      resourceManager.queryCache.clear();
    }

    if (cacheType === 'all' || cacheType === 'hemisphere') {
      clearedItems += resourceManager.hemisphereCache.size;
      resourceManager.hemisphereCache.clear();
    }

    console.log(`ðŸ§¹ Cache cleared: ${clearedItems} items removed`);

    res.json({
      message: 'Cache cleared successfully',
      type: cacheType,
      clearedItems,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/hemispheres/reset
 * Reset emisferi ai valori base
 */
router.post('/hemispheres/reset', async (req, res, next) => {
  try {
    const orchestrator = req.app.locals.orchestrator;
    const database = req.app.locals.database;
    
    const keepAutoGenerated = req.body.keepAutoGenerated !== false;
    
    console.log('ðŸ”„ Resetting hemispheres...');

    let removedCount = 0;
    const baseDomains = ['mathematics', 'logic', 'code', 'language'];

    // Rimuovi emisferi non base
    for (const [domain, hemisphere] of orchestrator.hemispheres) {
      if (!baseDomains.includes(domain)) {
        if (!keepAutoGenerated || !hemisphere.metadata.autoGenerated) {
          orchestrator.hemispheres.delete(domain);
          await database.run('DELETE FROM hemispheres WHERE domain = ?', [domain]);
          removedCount++;
        }
      }
    }

    // Reset statistiche emisferi base
    for (const domain of baseDomains) {
      const hemisphere = orchestrator.hemispheres.get(domain);
      if (hemisphere) {
        hemisphere.usageCount = 0;
        hemisphere.confidence = 0.5;
        hemisphere.lastUsed = new Date();
        await database.saveHemisphere(hemisphere.serialize());
      }
    }

    // Log evento
    await database.saveSystemEvent({
      type: 'hemispheres_reset',
      severity: 'info',
      message: `Hemispheres reset: ${removedCount} removed`,
      data: { removedCount, keepAutoGenerated },
      source: 'admin_api'
    });

    res.json({
      message: 'Hemispheres reset completed',
      removedCount,
      remainingHemispheres: Array.from(orchestrator.hemispheres.keys()),
      keepAutoGenerated,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/metrics/reset
 * Reset metriche sistema
 */
router.post('/metrics/reset', async (req, res, next) => {
  try {
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;
    const database = req.app.locals.database;
    
    const resetType = req.body.type || 'memory'; // memory, database, all
    
    let resetCount = 0;

    if (resetType === 'memory' || resetType === 'all') {
      // Reset metriche in memoria
      resetCount += resourceManager.performanceMetrics.length;
      resetCount += orchestrator.performanceMetrics.length;
      resetCount += orchestrator.ignorancePatterns.length;
      
      resourceManager.resetMetrics();
      orchestrator.performanceMetrics = [];
      orchestrator.ignorancePatterns = [];
      
      // Reset statistiche orchestrator
      orchestrator.stats = {
        totalQueries: 0,
        successfulQueries: 0,
        failedQueries: 0,
        autoGeneratedHemispheres: 0,
        averageConfidence: 0,
        averageResponseTime: 0
      };
    }

    if (resetType === 'database' || resetType === 'all') {
      // Reset metriche database
      const tables = ['performance_metrics', 'knowledge_gaps', 'ignorance_patterns'];
      
      for (const table of tables) {
        const result = await database.run(`DELETE FROM ${table}`);
        resetCount += result.changes || 0;
      }
    }

    // Log evento
    await database.saveSystemEvent({
      type: 'metrics_reset',
      severity: 'info',
      message: `Metrics reset: ${resetCount} items cleared`,
      data: { resetType, resetCount },
      source: 'admin_api'
    });

    res.json({
      message: 'Metrics reset completed',
      type: resetType,
      resetCount,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/admin/logs
 * Ottieni log sistema (se disponibili)
 */
router.get('/logs', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    const limit = Math.min(parseInt(req.query.limit) || 100, 500);
    const severity = req.query.severity;
    const hours = parseInt(req.query.hours) || 24;

    // Usa eventi di sistema come log
    let sql = 'SELECT * FROM system_events WHERE timestamp > ?';
    const params = [new Date(Date.now() - hours * 60 * 60 * 1000).toISOString()];

    if (severity) {
      sql += ' AND severity = ?';
      params.push(severity);
    }

    sql += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(limit);

    const logs = await database.all(sql, params);

    res.json({
      logs: logs.map(log => ({
        timestamp: log.timestamp,
        level: log.severity,
        message: log.message,
        type: log.event_type,
        source: log.source,
        data: log.data ? JSON.parse(log.data) : {}
      })),
      filters: {
        limit,
        severity,
        hours
      },
      total: logs.length
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/config/update
 * Aggiorna configurazione runtime (limitata)
 */
router.post('/config/update', async (req, res, next) => {
  try {
    const configSchema = Joi.object({
      confidenceThreshold: Joi.number().min(0).max(1),
      autoGenerationEnabled: Joi.boolean(),
      maxHemispheres: Joi.number().integer().min(1).max(100),
      cacheSize: Joi.number().integer().min(100).max(10000)
    });

    const { error, value } = configSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.details[0].message
      });
    }

    const orchestrator = req.app.locals.orchestrator;
    const resourceManager = req.app.locals.resourceManager;
    const database = req.app.locals.database;

    const updatedConfig = {};

    // Aggiorna configurazioni supportate
    if (value.confidenceThreshold !== undefined) {
      orchestrator.config.confidenceThreshold = value.confidenceThreshold;
      updatedConfig.confidenceThreshold = value.confidenceThreshold;
    }

    if (value.autoGenerationEnabled !== undefined) {
      orchestrator.config.autoGenerationEnabled = value.autoGenerationEnabled;
      updatedConfig.autoGenerationEnabled = value.autoGenerationEnabled;
    }

    if (value.maxHemispheres !== undefined) {
      orchestrator.config.maxHemispheres = value.maxHemispheres;
      updatedConfig.maxHemispheres = value.maxHemispheres;
    }

    if (value.cacheSize !== undefined) {
      resourceManager.config.cacheSize = value.cacheSize;
      updatedConfig.cacheSize = value.cacheSize;
    }

    // Log evento
    await database.saveSystemEvent({
      type: 'config_updated',
      severity: 'info',
      message: 'Runtime configuration updated',
      data: updatedConfig,
      source: 'admin_api'
    });

    res.json({
      message: 'Configuration updated successfully',
      updatedConfig,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/admin/stats
 * Statistiche amministrative dettagliate
 */
router.get('/stats', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;

    // Statistiche database dettagliate
    const dbStats = await database.getDatabaseStats();
    
    // Statistiche query per periodo
    const queryStats = await database.all(`
      SELECT 
        DATE(timestamp) as date,
        COUNT(*) as total,
        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful,
        AVG(processing_time) as avg_time,
        AVG(confidence) as avg_confidence
      FROM queries 
      WHERE timestamp > datetime('now', '-30 days')
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
    `);

    // Top emisferi per utilizzo
    const topHemispheres = await database.all(`
      SELECT 
        primary_hemisphere,
        COUNT(*) as usage_count,
        AVG(confidence) as avg_confidence,
        AVG(processing_time) as avg_time
      FROM queries 
      WHERE primary_hemisphere IS NOT NULL
      GROUP BY primary_hemisphere
      ORDER BY usage_count DESC
      LIMIT 10
    `);

    // Errori recenti
    const recentErrors = await database.all(`
      SELECT 
        event_type,
        message,
        timestamp,
        data
      FROM system_events 
      WHERE severity IN ('error', 'critical')
        AND timestamp > datetime('now', '-7 days')
      ORDER BY timestamp DESC
      LIMIT 20
    `);

    res.json({
      database: {
        size: (dbStats.databaseSize / 1024 / 1024).toFixed(2) + ' MB',
        tables: dbStats
      },
      
      performance: {
        system: resourceManager.getSystemStatus(),
        queries: resourceManager.getPerformanceStats()
      },
      
      trends: {
        queries: queryStats,
        hemispheres: topHemispheres
      },
      
      issues: {
        recentErrors: recentErrors.map(error => ({
          type: error.event_type,
          message: error.message,
          timestamp: error.timestamp,
          data: error.data ? JSON.parse(error.data) : {}
        }))
      },
      
      summary: {
        totalHemispheres: orchestrator.hemispheres.size,
        totalQueries: orchestrator.stats.totalQueries,
        systemUptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        nodeVersion: process.version
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/admin/pending-reviews
 * Ottieni review pendenti per validazione umana
 */
router.get('/pending-reviews', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    const limit = Math.min(parseInt(req.query.limit) || 50, 200);
    
    // Ottieni query con validation_status = 'pending_human_review'
    const pendingQueries = await database.all(
      `SELECT * FROM queries 
       WHERE json_extract(metadata, '$.validation_status') = 'pending_human_review'
       ORDER BY timestamp DESC
       LIMIT ?`,
      [limit]
    );

    const formattedQueries = pendingQueries.map(query => {
      const meta = JSON.parse(query.metadata || '{}');
      return {
        id: query.id,
        query: query.query_text,
        timestamp: query.timestamp,
        processingTime: query.processing_time,
        success: query.success === 1,
        confidence: query.confidence,
        mode: query.processing_mode,
        primaryHemisphere: query.primary_hemisphere,
        collaboratingHemispheres: query.collaborating_hemispheres ? 
          JSON.parse(query.collaborating_hemispheres) : [],
        metadata: meta,
        peer_review: meta.peer_review
      };
    });

    res.json({
      pending_reviews: formattedQueries,
      total: formattedQueries.length,
      metadata: {
        timestamp: new Date().toISOString(),
        limit
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/admin/reviews/:queryId/validate
 * Valida una query con review umana
 */
router.post('/reviews/:queryId/validate', async (req, res, next) => {
  try {
    const validationSchema = Joi.object({
      approved: Joi.boolean().required(),
      reviewer_name: Joi.string().required(),
      comments: Joi.string().optional(),
      quality_score: Joi.number().min(0).max(100).optional(),
      issues_found: Joi.array().items(Joi.string()).optional(),
      recommendations: Joi.array().items(Joi.string()).optional()
    });

    const { error, value } = validationSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.details[0].message
      });
    }

    const database = req.app.locals.database;
    const queryId = req.params.queryId;
    const { approved, reviewer_name, comments, quality_score, issues_found, recommendations } = value;

    // Ottieni query
    const query = await database.get(
      'SELECT * FROM queries WHERE id = ?',
      [queryId]
    );

    if (!query) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Query non trovata'
      });
    }

    // Aggiorna metadati
    const meta = JSON.parse(query.metadata || '{}');
    meta.validation_status = approved ? 'human_reviewed_approved' : 'human_reviewed_rejected';
    meta.reviewers = [...(meta.reviewers || []), reviewer_name];
    meta.human_review = {
      reviewer: reviewer_name,
      timestamp: new Date().toISOString(),
      approved,
      comments,
      quality_score,
      issues_found,
      recommendations
    };

    // Aggiorna database
    await database.run(
      'UPDATE queries SET metadata = ? WHERE id = ?',
      [JSON.stringify(meta), queryId]
    );

    // Salva evento
    await database.saveSystemEvent({
      event_type: 'human_review',
      severity: approved ? 'info' : 'warning',
      message: `Review umana ${approved ? 'approvata' : 'rifiutata'} per query ${queryId}`,
      data: JSON.stringify({
        query_id: queryId,
        reviewer: reviewer_name,
        approved,
        comments,
        quality_score,
        issues_found,
        recommendations
      }),
      source: 'human_reviewer'
    });

    res.json({
      success: true,
      message: `Review ${approved ? 'approvata' : 'rifiutata'} con successo`,
      query_id: queryId,
      validation_status: meta.validation_status,
      reviewer: reviewer_name
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/admin/validation-stats
 * Statistiche sulla validazione
 */
router.get('/validation-stats', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    // Statistiche per stato di validazione
    const validationStats = await database.all(`
      SELECT 
        json_extract(metadata, '$.validation_status') as status,
        COUNT(*) as count
      FROM queries 
      WHERE metadata IS NOT NULL
      GROUP BY json_extract(metadata, '$.validation_status')
    `);

    // Statistiche per tipo di contributo
    const contributionStats = await database.all(`
      SELECT 
        json_extract(metadata, '$.contribution_type') as type,
        COUNT(*) as count
      FROM queries 
      WHERE metadata IS NOT NULL
      GROUP BY json_extract(metadata, '$.contribution_type')
    `);

    // Statistiche per origine
    const originStats = await database.all(`
      SELECT 
        json_extract(metadata, '$.origin') as origin,
        COUNT(*) as count
      FROM queries 
      WHERE metadata IS NOT NULL
      GROUP BY json_extract(metadata, '$.origin')
    `);

    // Review pendenti
    const pendingCount = await database.get(`
      SELECT COUNT(*) as count
      FROM queries 
      WHERE json_extract(metadata, '$.validation_status') = 'pending_human_review'
    `);

    res.json({
      validation_stats: validationStats,
      contribution_stats: contributionStats,
      origin_stats: originStats,
      pending_reviews: pendingCount.count,
      metadata: {
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    next(error);
  }
});

module.exports = router;

