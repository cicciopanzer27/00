/**
 * Routes per metriche e performance AGI
 */

const express = require('express');
const router = express.Router();

/**
 * GET /api/v1/metrics
 * Ottieni panoramica metriche sistema
 */
router.get('/', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;

    // Metriche performance dal resource manager
    const performanceStats = resourceManager.getPerformanceStats();
    
    // Stato sistema
    const systemStatus = resourceManager.getSystemStatus();
    
    // Statistiche orchestrator
    const orchestratorStatus = orchestrator.getSystemStatus();
    
    // Statistiche database
    const dbStats = await database.getDatabaseStats();

    res.json({
      performance: performanceStats,
      system: {
        health: systemStatus.health,
        memory: systemStatus.memory,
        counters: systemStatus.counters,
        cache: systemStatus.cache,
        uptime: systemStatus.uptime
      },
      orchestrator: {
        hemispheres: orchestratorStatus.hemispheres.length,
        totalQueries: orchestratorStatus.totalQueries,
        averageResponseTime: orchestratorStatus.averageResponseTime,
        averageConfidence: orchestratorStatus.averageConfidence,
        autoGeneratedHemispheres: orchestratorStatus.autoGeneratedHemispheres,
        activeQueries: orchestratorStatus.activeQueries
      },
      database: dbStats,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/metrics/performance
 * Ottieni metriche performance dettagliate
 */
router.get('/performance', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const resourceManager = req.app.locals.resourceManager;
    
    const operation = req.query.operation;
    const limit = Math.min(parseInt(req.query.limit) || 100, 1000);
    const hours = parseInt(req.query.hours) || 24;

    // Metriche dal database
    let dbMetrics = await database.getPerformanceMetrics(operation, limit);
    
    // Filtra per tempo se specificato
    if (hours < 24 * 30) { // Solo se meno di 30 giorni
      const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
      dbMetrics = dbMetrics.filter(m => new Date(m.timestamp) > cutoff);
    }

    // Metriche in memoria dal resource manager
    const memoryMetrics = resourceManager.performanceMetrics.slice(-limit);

    // Analisi aggregata
    const analysis = analyzePerformanceMetrics(dbMetrics);

    res.json({
      database: {
        metrics: dbMetrics.map(m => ({
          timestamp: m.timestamp,
          operation: m.operation,
          duration: m.duration,
          success: m.success === 1,
          metadata: m.metadata ? JSON.parse(m.metadata) : {}
        })),
        analysis
      },
      memory: {
        metrics: memoryMetrics,
        analysis: analyzePerformanceMetrics(memoryMetrics)
      },
      filters: {
        operation,
        limit,
        hours
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/metrics/system
 * Ottieni metriche sistema in tempo reale
 */
router.get('/system', async (req, res, next) => {
  try {
    const resourceManager = req.app.locals.resourceManager;
    
    const systemStatus = resourceManager.getSystemStatus();
    const memoryUsage = resourceManager.getMemoryUsage();

    // Metriche sistema recenti
    const recentMemoryMetrics = resourceManager.systemMetrics.memory.slice(-20);
    const recentCpuMetrics = resourceManager.systemMetrics.cpu.slice(-20);

    res.json({
      current: {
        health: systemStatus.health,
        memory: memoryUsage,
        counters: systemStatus.counters,
        cache: systemStatus.cache,
        uptime: systemStatus.uptime,
        platform: systemStatus.platform,
        arch: systemStatus.arch,
        nodeVersion: systemStatus.nodeVersion
      },
      history: {
        memory: recentMemoryMetrics.map(m => ({
          timestamp: m.timestamp,
          heapUsed: m.heap.used,
          heapTotal: m.heap.total,
          heapPercentage: m.heap.percentage,
          systemUsed: m.system.used,
          systemTotal: m.system.total,
          systemPercentage: m.system.percentage
        })),
        cpu: recentCpuMetrics.map(m => ({
          timestamp: m.timestamp,
          user: m.user,
          system: m.system,
          cores: m.cores,
          loadAverage: m.loadAverage
        }))
      },
      alerts: systemStatus.health.warnings.concat(systemStatus.health.errors)
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/metrics/queries
 * Ottieni metriche specifiche per query
 */
router.get('/queries', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    
    const days = Math.min(parseInt(req.query.days) || 7, 90);
    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    // Statistiche query per giorno
    const dailyStats = await database.all(`
      SELECT 
        DATE(timestamp) as date,
        COUNT(*) as total_queries,
        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_queries,
        AVG(processing_time) as avg_processing_time,
        AVG(confidence) as avg_confidence,
        processing_mode,
        COUNT(DISTINCT primary_hemisphere) as unique_hemispheres
      FROM queries 
      WHERE timestamp > ?
      GROUP BY DATE(timestamp), processing_mode
      ORDER BY date DESC, processing_mode
    `, [cutoff.toISOString()]);

    // Distribuzione per emisfero
    const hemisphereDistribution = await database.all(`
      SELECT 
        primary_hemisphere,
        COUNT(*) as query_count,
        AVG(confidence) as avg_confidence,
        AVG(processing_time) as avg_processing_time,
        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_queries
      FROM queries 
      WHERE timestamp > ? AND primary_hemisphere IS NOT NULL
      GROUP BY primary_hemisphere
      ORDER BY query_count DESC
    `, [cutoff.toISOString()]);

    // Distribuzione per modalitÃ 
    const modeDistribution = await database.all(`
      SELECT 
        processing_mode,
        COUNT(*) as query_count,
        AVG(confidence) as avg_confidence,
        AVG(processing_time) as avg_processing_time,
        SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_queries
      FROM queries 
      WHERE timestamp > ?
      GROUP BY processing_mode
      ORDER BY query_count DESC
    `, [cutoff.toISOString()]);

    // Trend confidence nel tempo
    const confidenceTrend = await database.all(`
      SELECT 
        DATE(timestamp) as date,
        AVG(confidence) as avg_confidence,
        MIN(confidence) as min_confidence,
        MAX(confidence) as max_confidence,
        COUNT(*) as sample_size
      FROM queries 
      WHERE timestamp > ? AND confidence IS NOT NULL
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
    `, [cutoff.toISOString()]);

    res.json({
      period: {
        days,
        from: cutoff.toISOString(),
        to: new Date().toISOString()
      },
      daily: dailyStats,
      distribution: {
        byHemisphere: hemisphereDistribution,
        byMode: modeDistribution
      },
      trends: {
        confidence: confidenceTrend
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * GET /api/v1/metrics/knowledge-gaps
 * Ottieni metriche sui gap di conoscenza
 */
router.get('/knowledge-gaps', async (req, res, next) => {
  try {
    const database = req.app.locals.database;
    const orchestrator = req.app.locals.orchestrator;
    
    const limit = Math.min(parseInt(req.query.limit) || 50, 200);
    const resolved = req.query.resolved === 'true';

    // Gap dal database
    const knowledgeGaps = await database.getKnowledgeGaps(resolved, limit);

    // Pattern di ignoranza dall'orchestrator
    const ignorancePatterns = orchestrator.ignorancePatterns.slice(-50);

    // Analisi gap per tipo
    const gapsByType = await database.all(`
      SELECT 
        gap_type,
        COUNT(*) as count,
        AVG(severity) as avg_severity,
        MAX(timestamp) as last_occurrence
      FROM knowledge_gaps
      GROUP BY gap_type
      ORDER BY count DESC
    `);

    // Trend gap nel tempo
    const gapTrend = await database.all(`
      SELECT 
        DATE(timestamp) as date,
        COUNT(*) as gap_count,
        AVG(severity) as avg_severity
      FROM knowledge_gaps
      WHERE timestamp > datetime('now', '-30 days')
      GROUP BY DATE(timestamp)
      ORDER BY date DESC
    `);

    res.json({
      gaps: knowledgeGaps.map(gap => ({
        id: gap.id,
        query: gap.query_text,
        type: gap.gap_type,
        severity: gap.severity,
        timestamp: gap.timestamp,
        tokens: gap.tokens ? JSON.parse(gap.tokens) : [],
        suggestions: gap.suggestions ? JSON.parse(gap.suggestions) : [],
        resolved: gap.resolved === 1
      })),
      patterns: ignorancePatterns.map(pattern => ({
        query: pattern.query,
        timestamp: pattern.timestamp,
        hemisphereConfidences: pattern.hemisphereConfidences,
        knowledgeGaps: pattern.knowledgeGaps,
        hash: pattern.hash
      })),
      analysis: {
        byType: gapsByType,
        trend: gapTrend,
        totalGaps: knowledgeGaps.length,
        resolvedGaps: knowledgeGaps.filter(g => g.resolved === 1).length
      },
      filters: {
        limit,
        resolved
      }
    });

  } catch (error) {
    next(error);
  }
});

/**
 * POST /api/v1/metrics/reset
 * Reset metriche (admin)
 */
router.post('/reset', async (req, res, next) => {
  try {
    const resourceManager = req.app.locals.resourceManager;
    const orchestrator = req.app.locals.orchestrator;
    
    const resetType = req.body.type || 'memory'; // memory, database, all

    let resetCount = 0;

    if (resetType === 'memory' || resetType === 'all') {
      // Reset metriche in memoria
      resourceManager.resetMetrics();
      orchestrator.performanceMetrics = [];
      orchestrator.ignorancePatterns = [];
      resetCount++;
    }

    if (resetType === 'database' || resetType === 'all') {
      // Reset metriche database (mantieni solo ultimi 7 giorni)
      const database = req.app.locals.database;
      const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      
      const result = await database.run(
        'DELETE FROM performance_metrics WHERE timestamp < ?',
        [cutoff.toISOString()]
      );
      
      resetCount += result.changes || 0;
    }

    res.json({
      message: 'Metrics reset completed',
      type: resetType,
      resetCount,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    next(error);
  }
});

/**
 * Funzione helper per analisi metriche performance
 */
function analyzePerformanceMetrics(metrics) {
  if (metrics.length === 0) {
    return {
      total: 0,
      successful: 0,
      failed: 0,
      successRate: 0,
      averageDuration: 0,
      minDuration: 0,
      maxDuration: 0,
      medianDuration: 0
    };
  }

  const successful = metrics.filter(m => m.success === true || m.success === 1);
  const durations = metrics.map(m => m.duration).sort((a, b) => a - b);
  
  return {
    total: metrics.length,
    successful: successful.length,
    failed: metrics.length - successful.length,
    successRate: (successful.length / metrics.length * 100).toFixed(2),
    averageDuration: Math.round(durations.reduce((sum, d) => sum + d, 0) / durations.length),
    minDuration: durations[0],
    maxDuration: durations[durations.length - 1],
    medianDuration: durations[Math.floor(durations.length / 2)],
    p95Duration: durations[Math.floor(durations.length * 0.95)],
    p99Duration: durations[Math.floor(durations.length * 0.99)]
  };
}

module.exports = router;

